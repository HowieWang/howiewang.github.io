---
layout: post
title:  ruanyf的js教程学习笔记2-基本语法注意点
category: 
-   js

---

* content
{:toc}

> http://javascript.ruanyifeng.com/


## 函数

### 全局变量和局部变量

注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。

    if (true) {
      var x = 5;
    }
    console.log(x);  // 5


### 函数内部的变量提升

与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

    function foo(x) {
      if (x > 100) {
        var tmp = x - 100;
      }
    }

上面的代码等同于

    function foo(x) {
      var tmp;
      if (x > 100) {
        tmp = x - 100;
      };
    }


    ### 传递方式
函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。

    var p = 2;

    function f(p) {
      p = 3;
    }
    f(p);

    p // 2

上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。

但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。

    var obj = {p: 1};

    function f(o) {
      o.p = 2;
    }
    f(obj);

    obj.p // 2

上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。

** 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。**

    var obj = [1, 2, 3];

    function f(o){
      o = [2, 3, 4];
    }
    f(obj);

    obj // [1, 2, 3]

上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）与实际参数obj存在一个赋值关系.

某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。

    var a = 1;

    function f(p) {
      window[p] = 2;
    }
    f('a');

    a // 2

上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。


### 闭包  

如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。

    function f1() {
      var n = 999;
      function f2() {
    　　console.log(n); // 999
      }
    }

上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

> 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

    function f1() {
      var n = 999;
      function f2() {
        console.log(n);
      }
      return f2;
    }

    var result = f1();
    result(); // 999

上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。

**闭包就是函数f2，即能够读取其他函数内部变量的函数。**由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。**闭包最大的特点，就是它可以“记住”诞生的环境**，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

闭包的最大用处有两个，**一个是可以读取函数内部的变量，让这些变量始终保持在内存中，**即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。


    function createIncrementor(start) {
      return function () {
        return start++;
      };
    }

    var inc = createIncrementor(5);

    inc() // 5
    inc() // 6
    inc() // 7

上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。

为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收

**闭包的另一个用处，是封装对象的私有属性和私有方法。**

    function Person(name) {
      var _age;
      function setAge(n) {
        _age = n;
      }
      function getAge() {
        return _age;
      }

      return {
        name: name,
        getAge: getAge,
        setAge: setAge
      };
    }

    var p1 = person('张三');
    p1.setAge(25);
    p1.getAge() // 25


上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。

> 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

### 立即调用的函数表达式（IIFE）

能在函数的定义之后加上圆括号，这会产生语法错误。

解决方法就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算。你可以这样写：

    (function(){ /* code */ }());  // 必须有；

    // 或者

    (function(){ /* code */ })(); // 必须有；

这两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。

只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

    // 写法一
    var tmp = newData;
    processData(tmp);
    storeData(tmp);

    // 写法二
    (function (){
      var tmp = newData;
      processData(tmp);
      storeData(tmp);
    }()); 

上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。

### eval命令

通常情况下，eval最常见的场合是解析JSON数据字符串，正确的做法是这时应该使用浏览器提供的JSON.parse方法。

[read more](http://javascript.ruanyifeng.com/grammar/function.html)

-----

## 数值

JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

    0.1 + 0.2 === 0.3
    // false

    0.3 / 0.1
    // 2.9999999999999996

    (0.3 - 0.2) === (0.2 - 0.1)
    // false

根据国际标准IEEE 754，64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分（共52位），第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。

因此，JavaScript提供的有效数字的精度为53个二进制位（IEEE 754规定有效数字第一位默认总是为1，不保存在64位浮点数之中，这一位再加上后面的52位，就是总共53位），也就是说，绝对值小于2的53次方的整数，即-(253-1)到253-1，都可以精确表示。

NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合

NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。

NaN不等于任何值，包括它本身。

    NaN === NaN // false

isNaN方法可以用来判断一个值是否为NaN。

    isNaN(NaN) // true

判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断。

    function myIsNaN(value) {
      return value !== value;
    }


##  对象

JavaScript的所有数据都可以被视为对象。

简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。

对象的所有键名都是字符串，所以加不加引号都可以。

> 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号。

注意，JavaScript的保留字可以不加引号当作键名。

    var obj = {
      for: 1,
      class: 2
    };

### 属性

对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。

如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。

    var o = {
      0.7: "Hello World"
    };

    o.['0.7'] // "Hello World"
    o[0.7] // "Hello World"

### 运算符

为了得到正确的负数的余数值，需要先使用绝对值函数。

    // 错误的写法
    function isOdd(n) {
      return n % 2 === 1;
    }
    isOdd(-5) // false
    isOdd(-4) // false

    // 正确的写法
    function isOdd(n) {
      return Math.abs(n % 2) === 1;
    }
    isOdd(-5) // true
    isOdd(-4) // false

“或运算”的规则是，如果两个二进制位之中至少有一个位为1，则返回1，否则返回0。“与运算”的规则是，如果两个二进制位之中至少有一个位1为0，则返回0，否则返回1。

    0 | 3 // 3
    0 & 3 // 0

上面两个表达式，0和3的二进制形式分别是00和11，所以进行“或运算”会得到11（即3），进行”与运算“会得到00（即0）。

位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行或运算，等同于对该数去除小数部分，即取整数位。

    2.9 | 0
    // 2

### 否运算

“否运算”将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。

    ~ 3 // -4

上面表达式对3进行“否运算”，得到-4。之所以会有这样的结果，是因为位运算时，JavaScirpt内部将所有的运算子都转为32位的二进制整数再进行运算。3在JavaScript内部是00000000000000000000000000000011，否运算以后得到11111111111111111111111111111100，由于第一位是1，所以这个数是一个负数。JavaScript内部采用2的补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。

    ~ -3 // 2

上面表达式可以这样算，-3的取反值等于-1减去-3，结果为2。

对一个整数连续两次“否运算”，得到它自身。

    ~~3 // 3

所有的位运算都只对整数有效。否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次否运算，能达到取整效果。

    ~~2.9 // 2

> 使用否运算取整，是所有取整方法中最快的一种。


### 异或运算

“异或运算”在两个二进制位不同时返回1，相同时返回0。

    0^3 // 3

上面表达式中，0的二进制形式是00，3的二进制形式是11，它们每一个二进制位都不同，所以得到11（即3）。

“异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，aˆ=b, bˆ=a, aˆ=b，可以互换它们的值（详见维基百科）。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。

    var a = 10;
    var b = 99;

    a^=b, b^=a, a^=b;

    a // 99
    b // 10

这是互换两个变量的值的最快方法。

异或运算也可以用来取整。


    12.9^0 // 12

### 左移运算符

左移运算符表示将一个数的二进制形式向前移动，尾部补0。

    4 << 1
    // 8
    // 因为4的二进制形式为100，左移一位为1000（即十进制的8）

如果左移0位，就相当于取整，对于正数和负数都有效。


    13.5 << 0
    // 13

    -13.5 << 0
    // -13

> 左移运算符用于二进制数值非常方便。

    var color = {r: 186, g: 218, b: 85};

    // RGB to HEX
    var rgb2hex = function(r, g, b) {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).substr(1);
    }

    rgb2hex(color.r,color.g,color.b)
    // "#bada55"
    
上面代码使用左移运算符，将颜色的RGB值转为HEX值。

### 右移运算符（»）

右移运算符表示将一个数的二进制形式向右移动，头部补上最左位的值，即整数补0，负数补1。

    4 >> 1
    // 2
    /*
    // 因为4的二进制形式为00000000000000000000000000000100，
    // 右移一位得到00000000000000000000000000000010，
    // 即为十进制的2
    */

    -4 >> 1
    // -2
    /*
    // 因为-4的二进制形式为11111111111111111111111111111100，
    // 右移一位，头部补1，得到11111111111111111111111111111110,
    // 即为十进制的-2
    */

右移运算可以模拟2的整除运算。

    5 >> 1
    // 相当于 5 / 2 = 2

    21 >> 2
    // 相当于 21 / 4 = 5

    21 >> 3
    // 相当于 21 / 8 = 2

    21 >> 4
    // 相当于 21 / 16 = 1

### 带符号位的右移运算符（»>）

该运算符表示将一个数的二进制形式向右移动，不管正数或负数，头部一律补0。所以，该运算总是得到正值，这就是它的名称“带符号位的右移”的涵义。对于正数，该运算的结果与右移运算符（»）完全一致，区别主要在于负数。

    4 >>> 1
    // 2

    -4 >>> 1
    // 2147483646
    /*
    // 因为-4的二进制形式为11111111111111111111111111111100，
    // 带符号位的右移一位，得到01111111111111111111111111111110，
    // 即为十进制的2147483646。
    */

### 圆括号运算符

在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。

把表达式放在圆括号之中，将返回表达式的值。

    (1) // 1
    ('a') // a
    (1+2) // 3

把对象放在圆括号之中，则会返回对象的值，即对象本身。

    var o = {p:1};

    (o)
    // Object {p: 1}

### void运算符

void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。

    void(0) // undefined

这个运算符主要是用于书签工具（bookmarklet），以及用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。

    <a href="javascript:void window.open('http://example.com/')">
      点击打开新窗口
    </a>

上面代码用于在网页中创建一个链接，点击后会打开一个新窗口。如果没有void，点击后就会在当前窗口打开链接。

下面是常见的网页中触发鼠标点击事件的写法。

    <a href="http://example.com" onclick="f();">文字</a>

上面代码有一个问题，函数f必须返回false，或者说onclick事件必须返回false，否则会引起浏览器跳转到example.com。

    function f() {
      // some code
      return false;
    }

或者写成

    <a href="http://example.com" onclick="f();return false;">文字</a>
    // void运算符可以取代上面两种写法。

    <a href="javascript:void(f())">文字</a>
    // 下面的代码会提交表单，但是不会产生页面跳转。

    <a href="javascript:void(document.form.submit())">
    文字</a>
